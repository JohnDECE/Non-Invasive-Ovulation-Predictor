### Non-Invasive Ovulation Predictor Software
NOTE: This software was built in python 3.9.2 using the hmmlearn library, scikit-learn and scikit-image libraries, as well as other helper libraries like os, matplotlib, and tkinter.
1. Obtain the dataset recorded using the recorder software and hardware
2. Run Cluster.py
   - It will ask for the dataset's directory, it will automatically generate an output directory in the dataset's directory after it is done with all the clustered and segmented images
3. Run model.py 
   
   - This will also ask for the dataset's directory, I recommend inputting the results from the clustering. If you already previously trained a model then you can also opt to load in that. The main function in this script should handle everything.
   
If you would like to just use the scripts as libraries, that will also work given that all of my code was put into classes. Just follow what was done in the main functions of each script to make them work.

### Brief Code Descriptions:

FileParser.py:
2 Main Components:
   - directoryData Class
      
      - This Class is primarily meant to represent an entire directory of images that were generated by the **recorder** software. Each image file will be represented by a fileData object and the entire directory will be stored in a list sorted by the first value in the filename of each image. (This is just a value indicating the order in which each image was recorded in, lower indicates that the image was taken closer to the start of recording and vice versa).
      
   - fileData Class
      
      - This class encapsulates an image file generated by the **recorder** software. This class will take in an image's file name and a boolean indicating whether or not the file name has timestamps in it (during experimentation there was a slight miscommunication and there ended up being two types of files being generated, one without a timestamp but with the date of recording and the other with a timestamp and the date of recording. This boolean makes it easier to tell the fileData instance how to parse the file's name.)

The file name of each image contained a number indicating the order of recording, the date of recording and a timestamp if applicable. Then we simply had the image itself to work with.


Cluster.py:
This code performs k-means clustering (using K=4 clusters, this may not be optimal depending on one's images, one can play around with this number) on images.

   - clusterMaker class
   
      - This class will receive a directory file path and store the directory's image file names in self.fileList (NOTE: self.fileList is sorted by the modified time of each file, it may be more apt to use the sortKey() function from fileParser since that is what is used in directoryData when we load in image files to keep things consistent). Then one can simply run the cluster method by giving it the index of the image they want to cluster from self.fileList.
      - For ease of use, there is a method called cluster_directory_images which will cluster every single file in self.fileList using the cluster method.
      - Finally, we can save all of our images into a directory of your choosing (if not chosen, default directory is named "output" and is placed in the image directory) using the save_images_to_directory method.

Model.py:
This code runs a Hidden Markov Model (HMM) on images (should be clustered images).

   - PredictorModel Class

      - This class will handle all of the model initialization, training and prediction.
      - There is also capability to load in a previously trained model as well as save one's newly trained model using the loadModel/saveModel methods.
      - During initialization this class will take a directory's file path, a hasTime boolean just like in fileParser and a previously trained model's file path (if one wants to load one in, otherwise just don't pass one in, the class will generate a new model). The class will load in all of the images in the given directory and load in the model if the file path was given.
      - After initialization, it is a simple as calling the train() method (if one wants to generate a new model) and calling the predict() method for generating the predictions on the data. 
      - Then one can simply call the plot_results method to see what the predictions were in relation to the date of recording as a chart. Blue dots will indicate Ovulation and red dots will indicate non-ovulation.


For more detailed information, please reference the docstrings of the related file. All methods and functions were documented on how they worked in depth in the code itself.

